Apex HW

Question 1:

public class ApexHW1 {
    
    public static Integer fib(Integer n) {
        if (n <= 1) 
            return n;
            return fib(n-1) + fib(n-2);
    
        }
    
}


Execution Code:
	System.debug(ApexHW1.fib(10));

Explanation:
	n is less than or equal to 1
	code returns n since it will be whatever integer set
	to get fibonacci it takes the 1st integer minus 1 and adds
	fib 2nd integer minus 2 to get the fibonacci number

Question 2:

    public static Integer[] sortArray(Integer[] intList){
        for(Integer i = 0; i < intList.size(); i++) {
            for(Integer j = i; j < intList.size(); j++) {
                Integer x;
                if(intList[i]>intList[j]){
                    x = intList[i];
                    intList[i] = intList[j];
                    intList[j] = x;
                    
                }
            }
        }
        
        return intList;
    }

	
Execution Code:
	List<Integer> intList<Integer> {2,4,5,1,3,1};
	System.debug(ApexHW1.sortArray(intList));
Explanation:
	the code is set to accept a list of integers of any size in
	any order and will automatically sort them when code is
	executed

Question 3:

 public static Integer factorial(Integer n){ 

    return (n==1 || n==0) ? 1: n * factorial(n - 1); 
    }
	
Execution Code:
	System.debug(ApexHW1.factorial(10));

Explanation:
	integer times the factorial (which is n - 1) to get output

Question 4: 
  public static Integer[] rotateLeftNTimes(Integer[] arrayDot, Integer n) {
		Integer x;
        for (Integer i=0; i<n; i++){
            x=arrayDot[0];
            for (Integer j=0; j<arrayDot.size()-1; j++){
                arrayDot[j]= arrayDot[j+1];
            }
            arrayDot[arrayDot.size()-1]=x;
        }
        return arrayDot;
  }


Execution Code:
	List<Integer> arrayDot = new List<Integer>{1,2,3,4,5};
	System.debug(ApexHW1.rotateLeftNTimes(arrayDot, 1));

Explanation:
	code can take an array list of any size (doesn't care about 	order) and will take the 1st integer and will move it however 	many spots you want

Question 5:
	
	
Execution Code:
	
Explanation:


Question 6:

 public static void updateAccountSize(){
        List<Account> accountList = [SELECT Size__c, NumberOfEmployees FROM Account];
        
        for(Account a: accountList){
            if(a.NumberOfEmployees < 1000){
                a.Size__c = 'small';
            } else if(a.NumberOfEmployees >= 1000 && a.NumberOfEmployees < 10000){
                a.Size__c = 'medium';
            } else {
                a.Size__c = 'large';
            }
            update accountList;
        }
        
    }

Execution Code:
	ApexHW1.updateAccountSize();

Explanation:
	the code will go through all account information and reclass 
	accounts based on size with the size field added in the 	Account object. the sizes are based on employee numbers
	small is 1000 employees or less
	medium is between 1000 - 10000 employees
	large is more than 10000 employees
	you can tell it worked by looking at the account information
	of any of the pre-set accounts, you will see that they are 	automatically updated into their respective sizes

Question 7:

Execution Code:

Explanation:


Question 8:


Execution Code:

Explanation:

